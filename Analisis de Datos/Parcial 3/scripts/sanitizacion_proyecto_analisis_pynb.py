# -*- coding: utf-8 -*-
"""Sanitizacion_proyecto_analisis.pynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ZYy_YQffyuMcJjvf-FoqkOY9WiZGzy_
"""

import pandas as pd
import numpy as np

columnas_validas = [
    'Genero','Edad','HorasTrabajo','GiroTrabajo','AreaDeEstudio','DescalcificacionEnGestacion',
    'ConsumioOmega3','FamiliaDisfuncional','ActividadesEnInfancia','AhorroEnInfancia',
    'ComprasEnInfancia','TrabajoEnInfancia','LugarDeDesarrollo','TipoEscuelaPrevia',
    'ExperienciaPrevia','HorasEstudio','RendimientoProgramacion','UsoHerramientasIA',
    'MotivacionPrincipal','ExperienciaPreviaLogica','NivelIngles','MetodoDeEstudio',
    'TiempoHogarEscuela','MedioTransporte','HorasDeSueno','TiempoEjercicioSemana',
    'ConsumoCafeina','ConsumoCafe','ConsumoBebidaAzucarada','DietaBalanceada','ActividadesExtra',
    'ConsumeEstupefaciente','ConsumeEstupefacienteControl','MedicadoPrevioCarrera',
    'UsoVideojuegos','GeneroVideojuegoFav','MateriaFavoritaPrimaria','DeporteFavoritoVer',
    'DeporteFavoritoPracticar','NivelInstrumentoMusical','InstrumentoMusical','TipoAprendizaje',
    'PensamientoLogico1','PensamientoLogico2','PensamientoLogico3','PensamientoLogico4',
    'ResilienciaFrustracion1','ResilienciaFrustracion2','ResilienciaFrustracion3',
    'ResilienciaFrustracion4','ResilienciaFrustracion5',
    ]


# Ruta de del CSV sin sanitizar
INPUT_CSV = "RespuestasSinSanitizar.csv"
OUTPUT_CSV = "RespuestasSanitizadas.csv"

# Cargar el csv con su contenido como strings, sin hacer inferencia de tipos
dataframe = pd.read_csv(INPUT_CSV, dtype=str, encoding="utf-8-sig")


# 1. Corregir errores de Formato


# Hacer drop de las dos primeras columnas del CSV, ya que forms agrega dos columnas
# antes de las respuestas (marca temporal y Lea los siguientes terminos y condiciones...)

indices_a_eliminar = [0, 1]
dataframe = dataframe.drop(dataframe.columns[indices_a_eliminar], axis=1)

# cambiamos los headers para que coincidan con el nombre de nuestras variables
dataframe.columns = columnas_validas


# Remover espacios en blanco innecesarios
for columna in dataframe.columns:
  dataframe[columna] = dataframe[columna].str.strip()


#convertimos los valores numericos a int o float respectivamente
columnas_numericas_enteras = [
    'Edad', 'HorasTrabajo', 'HorasEstudio', 'RendimientoProgramacion',
    'HorasDeSueno', 'TiempoHogarEscuela','TiempoEjercicioSemana',
    'ConsumoCafeina','ConsumoCafe','ConsumoBebidaAzucarada', 'UsoVideojuegos',
    'ResilienciaFrustracion1','ResilienciaFrustracion2','ResilienciaFrustracion3',
    'ResilienciaFrustracion4','ResilienciaFrustracion5',
    ]

columnas_numericas_flotantes = [
  'PensamientoLogico1','PensamientoLogico2','PensamientoLogico3','PensamientoLogico4',
]

#intentamos convertir los valores de las columnas numericas enteras a tipo int,
#si el valor no es convertible lo dejamos vacio
for columna in columnas_numericas_enteras:
  dataframe[columna] = pd.to_numeric(dataframe[columna], errors='coerce').astype('Int64')

#intentamos convertir los valores de las columnas numericas flotantes a tipo float
#si el valor no es convertiblo lo dejamos vacio
for columna in columnas_numericas_flotantes:
  dataframe[columna] = pd.to_numeric(dataframe[columna], errors='coerce').astype('float')

# 2. Procesar variables multiseccion

# Para esta seccion se hizo un analisis sobre las respuestas para determinar
# cuales datos obtenidos a partir de la opcion "otro:" re etiquetar hacia
# otra categoria o simplemente eliminarlo para su posterior imputacion.

# se separa en las siguientes columnas binarias

# Dependiendo del contenido de la respuesta, que es una serie de strings
# separados por coma que pueden hacer match con algunas de estas columnas
# se pondra 1 si contiene el string que pertenece a la respuesta para
# esa columna y 0 si no


mapa_experiencia_logica = {
    'ExperienciaPreviaLogica_Ajedrez' : 'Ajedrez',
    'ExperienciaPreviaLogica_Debate' : 'Debate',
    'ExperienciaPreviaLogica_Filosofia' : 'Filosofía',
    'ExperienciaPreviaLogica_Matematicas' : 'Matemáticas Avanzadas',
}

mapa_metodo_estudio = {
    'MetodoDeEstudio_MapasConceptuales' : 'Realizar mapas conceptuales',
    'MetodoDeEstudio_Resumenes' : 'Realizar mapas conceptuales',
    'MetodoDeEstudio_Lectura' : 'Lectura y relectura',
    'MetodoDeEstudio_Ejercicios' : 'Practicar con ejercicios',
    'MetodoDeEstudio_VideosTutoriales' : 'Ver videos tutoriales',
}

mapa_instrumento_musical = {
    'InstrumentoMusical_Piano' : 'Piano',
    'InstrumentoMusical_Cuerdas' : 'Guitarra',
    'InstrumentoMusical_CuerdasSinfonica' : 'Violín',
    'InstrumentoMusical_Vientos' : 'Flauta',
    'InstrumentoMusical_Percusión' : 'Batería',
}

mapa_actividades_extra = {
    'ActividadesExtra_Laborales' : 'Laborales',
    'ActividadesExtra_TareasHogar' : 'Tareas del hogar',
    'ActividadesExtra_CuidadoFamiliar' : 'Cuidado de familiares',
    'ActividadesExtra_CompromisoSocial' : 'Compromisos sociales',
}


diccionario_mapas = {
    'ExperienciaPreviaLogica' : mapa_experiencia_logica,
    'MetodoDeEstudio' : mapa_metodo_estudio,
    'ActividadesExtra' : mapa_actividades_extra,
    'InstrumentoMusical' : mapa_instrumento_musical
}


for columna, mapa in diccionario_mapas.items():

  col_fuente = columna
  columnas = list(mapa.keys())

  pos_fuente = dataframe.columns.get_loc(col_fuente)

    # Crear e insertar las nuevas columnas justo después de la fuente
  for offset, (nueva_col, patron) in enumerate(mapa.items(), start=1):
      serie_binaria = (
          dataframe[col_fuente]
          .astype(str)
          .str.contains(patron, case=False, na=False)
          .astype(int)
      )
      # Insertar después de la columna fuente, respetando el orden del dictionary
      dataframe.insert(pos_fuente + offset, nueva_col, serie_binaria)

  # Al final, eliminamos la columna fuente
  dataframe.drop(columns=[col_fuente], inplace=True)



mapa_actividades = {
    'ActividadesEnInfancia_JuegoFisico': 'Juego físico',
    'ActividadesEnInfancia_JuegoCreativo': 'Juego creativo',
    'ActividadesEnInfancia_JuegoSimbolico': 'Juego simbólico',
    'ActividadesEnInfancia_JuegoTecnologico': 'Juego tecnológico',
    'ActividadesEnInfancia_ActividadesSocioCulturales': 'Actividades socioculturales',
}


col_fuente = 'ActividadesEnInfancia'

columnas_actividades_infancia = list(mapa_actividades.keys())

# Posición de la columna fuente
pos_fuente = dataframe.columns.get_loc(col_fuente)

# Crear e insertar las nuevas columnas justo después de la fuente
for offset, (nueva_col, patron) in enumerate(mapa_actividades.items(), start=1):
    serie_binaria = (
        dataframe[col_fuente]
        .astype(str)
        .str.contains(patron, case=False, na=False)
        .astype(int)
    )
    # Insertar después de la columna fuente, respetando el orden del dictionary
    dataframe.insert(pos_fuente + offset, nueva_col, serie_binaria)

texto = dataframe[col_fuente].astype(str)

# a) 'nada, no tenia tiempo' -> todas 0
mask_nada = texto.str.contains('nada, no tenia tiempo', case=False, na=False)
dataframe.loc[mask_nada, columnas_actividades_infancia] = 0

# b) 'un poco de todo ' -> todas 1
mask_todo = texto.str.contains('un poco de todo', case=False, na=False)
dataframe.loc[mask_todo, columnas_actividades_infancia] = 1

# c) 'Artes Marciales' -> solo JuegoFisico = 1, las demás 0
mask_artes = texto.str.contains('Artes Marciales', case=False, na=False)
dataframe.loc[mask_artes, columnas_actividades_infancia] = 0
dataframe.loc[mask_artes, 'ActividadesEnInfancia_JuegoFisico'] = 1


# Al final, eliminamos la columna fuente
dataframe.drop(columns=[col_fuente], inplace=True)


# 3. Codificar categorias

columnas_si_no = [
    'AhorroEnInfancia', 'TrabajoEnInfancia', 'ExperienciaPrevia',
    'ConsumeEstupefaciente','ConsumeEstupefacienteControl','MedicadoPrevioCarrera',
]

#Binarizamos las respuestas si/no
for columna in columnas_si_no:
  dataframe[columna] = dataframe[columna].map({'Sí': 1, 'No': 0})


# Re etiquetado manual de ciertas respuestas antes de hacer one hot encoding

dataframe['MotivacionPrincipal'] = dataframe['MotivacionPrincipal'].map({
    'Pasión/Curiosidad intelectual' : 'Pasion',
    'Oportunidades laborales/Salario' : 'Oportunidades',
    'Requisito académico/laboral' : 'Requisito',
    'La primera y la segunda' : 'Pasion',
    'Todas las anteriores' : 'Oportunidades',
    'Obligación' : 'Requisito',
    'Oportunidades laborales y para aplicarla en otra carrera' : 'Oportunidades',
    'Pasión y salario' : 'Pasion',
    'Más que nada desde niño siempre soñé con trabajar con todo relacionado con el software' : 'Pasion'
    })


dataframe['GiroTrabajo'] = dataframe['GiroTrabajo'].map({
    'Retail y atención al cliente (tiendas departamentales, supermercados, boutiques, tiendas de electrónica, cajero, vendedor de piso)' : 'Retail_Atencion',
    'Servicios de alimentos (restaurantes, cafeterías, comida rápida, servicio a mesas, barista)' : 'Alimentos',
    'Trabajo administrativo y captura de datos (asistente administrativo, recepción, auxiliar de archivo, captura de información para empresas o instituciones)' : 'Administrativo',
    'Soporte técnico (instalación de software, asistencia en fallas simples de equipos, configuración de redes pequeñas, atención de tickets de TI)' : 'Soporte_Tecnico',
    'Desarrollo o asistencia en ingeniería (programador junior, tester, asistente de laboratorio, apoyo en proyectos de diseño, análisis o control de calidad)' : 'Desarrollo_Ingenieria',
    'No trabajo' : 'No trabajo',
    'Imprenta, apoyo en ventas y produccion' : 'Administrativo',
    'Indutria Automotriz' : 'Automotriz',
    'mecanico' : 'Automotriz',
    'tec de buses' : 'Automotriz',
    'Manofactura' : 'Manufactura',
    'Maquila' : 'Manufactura',
    'mantenimiento industrial' : 'Manufactura',
    'Empresa integradora de tecnologias de telecomunicación, infraestructura de red, control de acceso' : 'Soporte_Tecnico'
})

dataframe['MedioTransporte'] = dataframe['MedioTransporte'].map({
    'A pie': 'Pie',
    'En carro (manejo)': 'Carro_Conductor',
    'En carro (alguien más maneja)': 'Carro_Pasajero',
    'Transporte público': 'Transporte_Publico',
    'Bicicleta': 'Bicicleta',
    'Motocicleta': 'Motocicleta',
    'Patineta' : 'Patineta',
    'Transporte, tren y a pie' : 'Transporte_Publico'
})
#Aplicamos one hot-encoding a las columnas correspondientes

columnas_one_hot = [
    'Genero', 'DescalcificacionEnGestacion',
    'ConsumioOmega3','FamiliaDisfuncional', 'TipoEscuelaPrevia',
    'UsoHerramientasIA', 'NivelIngles', 'DietaBalanceada', 'NivelInstrumentoMusical',
    'TipoAprendizaje', 'MateriaFavoritaPrimaria', 'MotivacionPrincipal', 'GiroTrabajo',
    'MedioTransporte'
]

for col in columnas_one_hot:

    # One hot encoding con el nombre de la columna como prefijo
    dummies = pd.get_dummies(
        dataframe[col],
        prefix=col,
        dtype=int
    )
    pos = dataframe.columns.get_loc(col)

    # Insertar cada dummy a la derecha de la columna original
    for i, dummy_col in enumerate(dummies.columns):
        dataframe.insert(
            pos + 1 + i,              # posición: después de la original, respetando orden
            dummy_col,
            dummies[dummy_col]
        )

# Al final, eliminar las columnas originales
dataframe.drop(columns=columnas_one_hot, inplace=True)

# 4. Imputacion de valores faltantes

columnas_pensamiento_logico = {
    'PensamientoLogico1': 19,
    'PensamientoLogico2': 19,
    'PensamientoLogico3': 2,
    'PensamientoLogico4': 14,
}


for col, valor_correcto in columnas_pensamiento_logico.items():

    # Filtrar solo respuestas numéricas incorrectas
    mask_incorrectas = dataframe[col].notna() & (dataframe[col] != valor_correcto)
    valores_incorrectos = dataframe.loc[mask_incorrectas, col]

    if valores_incorrectos.empty:
        print(f"[AVISO] No hay respuestas incorrectas para calcular la mediana en '{col}'. Se omite imputación.")
        continue

    mediana_incorrectas = valores_incorrectos.median()

    # Imputar SOLO en NaN (no tocamos respuestas correctas ni incorrectas existentes)
    dataframe[col] = dataframe[col].fillna(mediana_incorrectas)


# Columnas "Especiales"

cols_cat = [
    'AreaDeEstudio',
    'ComprasEnInfancia',
    'LugarDeDesarrollo',
    'GeneroVideojuegoFav',
    'DeporteFavoritoVer',
    'DeporteFavoritoPracticar',
]

def limpiar_area_estudio(valor):
    # Agrupa variantes de desarrollo de software, programación, etc.
    if pd.isna(valor):
        return np.nan
    s = str(valor).strip()
    if s == "":
        return np.nan
    s_low = s.lower()

    if 'desarrollo' in s_low and 'software' in s_low:
        return 'Desarrollo de software'
    if 'programación' in s_low or 'programacion' in s_low:
        return 'Programación'
    if 'mecatr' in s_low:
        return 'Mecatrónica'
    if 'electromec' in s_low:
        return 'Electromecánica'
    if 'electrónic' in s_low or 'electronica' in s_low:
        return 'Electrónica'
    if 'calidad total' in s_low or ('calidad' in s_low and 'productividad' in s_low):
        return 'Calidad y productividad'


    return 'Otro'

def limpiar_genero_videojuego(valor):
    """
    Pregunta: Género de videojuego favorito.
    Opciones objetivo:
    - Estrategia, RPG (Rol), Puzzles, FPS (Disparos),
      Simulación, No juego videojuegos, Otro
    """
    if pd.isna(valor):
        return np.nan
    s = str(valor).strip()
    if s == "":
        return np.nan
    s_low = s.lower()

    if 'no juego' in s_low:
        return 'No juego videojuegos'
    if 'estrategia' in s_low:
        return 'Estrategia'
    if 'rpg' in s_low:
        return 'RPG (Rol)'
    if 'puzzle' in s_low:
        return 'Puzzles'
    if 'fps' in s_low or 'disparos' in s_low:
        return 'FPS (Disparos)'
    if 'simul' in s_low:
        return 'Simulación'

    # Todo lo que salió de "Otro" u otros textos libres
    return 'Otro'


def limpiar_deporte(valor):
    """
    Para DeporteFavoritoVer / DeporteFavoritoPracticar.
    Opciones objetivo:
    - Fútbol Soccer, Ajedrez, Baloncesto, Béisbol, Ninguno, Otro
    """
    if pd.isna(valor):
        return np.nan
    s = str(valor).strip()
    if s == "":
        return np.nan
    s_low = s.lower()

    # Ninguno (con may/minus)
    if 'ninguno' in s_low:
        return 'Ninguno'
    # Fútbol Soccer
    if 'fútbol soccer' in s_low or 'futbol soccer' in s_low:
        return 'Fútbol Soccer'
    # Ajedrez
    if 'ajedrez' in s_low:
        return 'Ajedrez'
    # Baloncesto
    if 'baloncesto' in s_low:
        return 'Baloncesto'
    # Béisbol
    if 'béisbol' in s_low or 'beisbol' in s_low:
        return 'Béisbol'

    # Todo lo demás (box, tenis, voleibol, lol, etc.) se agrupa en "Otro"
    return 'Otro'



# Normalización específica
dataframe['AreaDeEstudio'] = dataframe['AreaDeEstudio'].apply(limpiar_area_estudio)
dataframe['GeneroVideojuegoFav'] = dataframe['GeneroVideojuegoFav'].apply(limpiar_genero_videojuego)
dataframe['DeporteFavoritoVer'] = dataframe['DeporteFavoritoVer'].apply(limpiar_deporte)
dataframe['DeporteFavoritoPracticar'] = dataframe['DeporteFavoritoPracticar'].apply(limpiar_deporte)

# Imputación de faltantes categóricas -> "SinRespuesta"
for col in cols_cat:
    dataframe[col] = dataframe[col].fillna('SinRespuesta')


for col in cols_cat:
    dummies = pd.get_dummies(dataframe[col], prefix=col, dtype=int)

    # Posición actual de la columna original
    pos = dataframe.columns.get_loc(col)

    # Insertar cada dummy justo después de la columna fuente
    for i, dummy_col in enumerate(dummies.columns):
        dataframe.insert(pos + 1 + i, dummy_col, dummies[dummy_col])

# Eliminar columnas originales de texto
dataframe.drop(columns=cols_cat, inplace=True)

# exportamos el csv
dataframe.to_csv(OUTPUT_CSV, index=False, encoding="utf-8-sig")

